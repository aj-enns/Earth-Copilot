name: Deploy Earth Copilot

on:
  workflow_dispatch:
    inputs:
      force_all:
        description: 'Force deploy all components'
        required: false
        default: false
        type: boolean
      disable_auth:
        description: 'Disable Entra ID authentication (app will be publicly accessible — dev/test only)'
        required: false
        default: false
        type: boolean
      disable_private_endpoints:
        description: 'Disable private endpoints (uses public access with cheaper SKUs — dev/test only)'
        required: false
        default: false
        type: boolean
      environment_name:
        description: 'GitHub Environment name (must have AZURE_CREDENTIALS secret configured)'
        required: true
        default: 'dev'
        type: string

permissions:
  contents: read
  id-token: write

# Prevent concurrent deployments from racing and causing DeploymentActive conflicts
concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

# All environment-specific values come from GitHub Environment variables (vars.)
# with sensible defaults so new users can deploy without any configuration.
# To customize, set these in your GitHub Environment (Settings -> Environments -> <your-env-name>):
#   vars.RESOURCE_GROUP  — Azure resource group name (default: rg-earthcopilot)
#   vars.LOCATION        — Azure region (default: eastus2)
#   vars.PROJECT_NAME    — Project prefix for naming resources (default: earthcopilot)
env:
  RESOURCE_GROUP: ${{ vars.RESOURCE_GROUP || 'rg-earthcopilot' }}
  LOCATION: ${{ vars.LOCATION || 'eastus2' }}
  PROJECT_NAME: ${{ vars.PROJECT_NAME || 'earthcopilot' }}

jobs:
  # Detect which components changed
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      infra: ${{ steps.filter.outputs.infra }}
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect file changes
        id: filter
        run: |
          # For manual trigger with force_all, deploy everything
          if [ "${{ github.event.inputs.force_all }}" == "true" ]; then
            echo "infra=true" >> $GITHUB_OUTPUT
            echo "backend=true" >> $GITHUB_OUTPUT
            echo "frontend=true" >> $GITHUB_OUTPUT
            echo " Force deploy all components"
            exit 0
          fi
          
          # Get changed files
          if [ "${{ github.event_name }}" == "push" ]; then
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
          else
            # For manual trigger without force_all, deploy everything
            echo "infra=true" >> $GITHUB_OUTPUT
            echo "backend=true" >> $GITHUB_OUTPUT
            echo "frontend=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Check each component
          INFRA_CHANGED=false
          BACKEND_CHANGED=false
          FRONTEND_CHANGED=false
          
          if echo "$CHANGED_FILES" | grep -q "^earth-copilot/infra/"; then
            INFRA_CHANGED=true
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^earth-copilot/container-app/"; then
            BACKEND_CHANGED=true
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^earth-copilot/web-ui/"; then
            FRONTEND_CHANGED=true
          fi
          
          # If workflow file changed, deploy all
          if echo "$CHANGED_FILES" | grep -q "^.github/workflows/deploy.yml"; then
            INFRA_CHANGED=true
            BACKEND_CHANGED=true
            FRONTEND_CHANGED=true
          fi
          
          echo "infra=$INFRA_CHANGED" >> $GITHUB_OUTPUT
          echo "backend=$BACKEND_CHANGED" >> $GITHUB_OUTPUT
          echo "frontend=$FRONTEND_CHANGED" >> $GITHUB_OUTPUT
          
          echo ""
          echo " Components to deploy:"
          echo "  Infrastructure: $INFRA_CHANGED"
          echo "  Backend: $BACKEND_CHANGED"
          echo "  Frontend: $FRONTEND_CHANGED"

  # Deploy Infrastructure (only if infra files changed)
  deploy-infrastructure:
    name: Deploy Infrastructure
    needs: detect-changes
    if: needs.detect-changes.outputs.infra == 'true'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment_name }}
    outputs:
      container_registry_name: ${{ steps.discover.outputs.container_registry_name }}
      container_app_name: ${{ steps.discover.outputs.container_app_name }}
      container_app_url: ${{ steps.discover.outputs.container_app_url }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy Infrastructure with Bicep
        run: |
          cd earth-copilot
          
          DEPLOYMENT_NAME="${{ env.PROJECT_NAME }}-$(date +%Y%m%d-%H%M%S)"
          # Private endpoints are ON by default; only disabled if user explicitly checks disable_private_endpoints
          if [ "${{ github.event.inputs.disable_private_endpoints }}" == "true" ]; then
            ENABLE_PE="false"
          else
            ENABLE_PE="true"
          fi
          
          echo "Deploying Infrastructure..."
          echo "  Private Endpoints: $ENABLE_PE"
          
          az deployment sub create \
            --location "${{ env.LOCATION }}" \
            --template-file infra/main.bicep \
            --parameters environmentName="${{ env.PROJECT_NAME }}" \
            --parameters location="${{ env.LOCATION }}" \
            --parameters deployAIFoundry=true \
            --parameters containerImage="" \
            --parameters enablePrivateEndpoints=$ENABLE_PE \
            --name "$DEPLOYMENT_NAME" \
            --output none
          
          echo "Infrastructure deployed successfully"

      - name: Discover Resource Names
        id: discover
        run: |
          echo "Discovering deployed resource names..."
          
          # Discover Container Registry
          ACR_NAME=$(az acr list --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv)
          echo "container_registry_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "  Container Registry: $ACR_NAME"
          
          # Discover Container App
          CA_NAME=$(az containerapp list --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv)
          echo "container_app_name=$CA_NAME" >> $GITHUB_OUTPUT
          echo "  Container App: $CA_NAME"
          
          # Get Container App URL
          if [ -n "$CA_NAME" ]; then
            CA_URL=$(az containerapp show --name "$CA_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query "properties.configuration.ingress.fqdn" -o tsv)
            echo "container_app_url=https://$CA_URL" >> $GITHUB_OUTPUT
            echo "  Container App URL: https://$CA_URL"
          fi

  # Deploy Backend (if backend files changed OR infra deployed)
  deploy-backend:
    name: Deploy Backend
    needs: [detect-changes, deploy-infrastructure]
    if: |
      always() &&
      (needs.detect-changes.outputs.backend == 'true' || needs.detect-changes.outputs.infra == 'true') &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped')
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment_name }}
    outputs:
      container_app_url: ${{ steps.deploy.outputs.container_app_url }}
      container_app_name: ${{ steps.discover.outputs.container_app_name }}
      container_registry_name: ${{ steps.discover.outputs.container_registry_name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Discover Resource Names
        id: discover
        run: |
          echo "Discovering resource names..."
          
          # Discover Container Registry
          ACR_NAME=$(az acr list --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv)
          if [ -z "$ACR_NAME" ]; then
            echo "ERROR: No Container Registry found in ${{ env.RESOURCE_GROUP }}"
            echo "   Run infrastructure deployment first!"
            exit 1
          fi
          echo "container_registry_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "  Container Registry: $ACR_NAME"
          
          # Discover Container App Environment
          CAE_NAME=$(az containerapp env list --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv)
          if [ -z "$CAE_NAME" ]; then
            echo "ERROR: No Container App Environment found in ${{ env.RESOURCE_GROUP }}"
            echo "   Run infrastructure deployment first!"
            exit 1
          fi
          echo "container_app_env_name=$CAE_NAME" >> $GITHUB_OUTPUT
          echo "  Container App Environment: $CAE_NAME"
          
          # Discover Container App (may not exist yet on first deploy)
          CA_NAME=$(az containerapp list --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv)
          if [ -z "$CA_NAME" ]; then
            echo "  INFO: No Container App found - will create one"
            echo "container_app_exists=false" >> $GITHUB_OUTPUT
          else
            echo "container_app_name=$CA_NAME" >> $GITHUB_OUTPUT
            echo "container_app_exists=true" >> $GITHUB_OUTPUT
            echo "  Container App: $CA_NAME"
          fi

      - name: Build and Deploy Backend
        id: deploy
        run: |
          echo " Building and deploying backend..."
          
          ACR_NAME="${{ steps.discover.outputs.container_registry_name }}"
          CAE_NAME="${{ steps.discover.outputs.container_app_env_name }}"
          CA_EXISTS="${{ steps.discover.outputs.container_app_exists }}"
          CA_NAME="${{ steps.discover.outputs.container_app_name }}"
          
          cd earth-copilot/container-app
          
          # Build and push image
          # When private endpoints are enabled, use the VNet-integrated agent pool
          # so the build agent can reach the private ACR without public internet
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          IMAGE_TAG="$TIMESTAMP"
          
          AGENT_POOL_ARGS=""
          if [ "${{ github.event.inputs.disable_private_endpoints }}" != "true" ]; then
            echo "Using VNet-integrated agent pool for private ACR build..."
            AGENT_POOL_ARGS="--agent-pool buildpool"
          fi
          
          az acr build \
            --registry "$ACR_NAME" \
            $AGENT_POOL_ARGS \
            --image "${{ env.PROJECT_NAME }}-api:$IMAGE_TAG" \
            --image "${{ env.PROJECT_NAME }}-api:latest" \
            --file Dockerfile.complete \
            ../
          
          echo "Image built: ${ACR_NAME}.azurecr.io/${{ env.PROJECT_NAME }}-api:$IMAGE_TAG"
          
          # Get ACR login server
          ACR_LOGIN_SERVER=$(az acr show \
            --name "$ACR_NAME" \
            --resource-group "${{ env.RESOURCE_GROUP }}" \
            --query "loginServer" -o tsv)
          
          if [ "$CA_EXISTS" == "true" ]; then
            # Update existing Container App
            echo "Updating existing Container App..."
            
            # Fetch current credentials to ensure env vars are up-to-date
            echo "Fetching service credentials..."
            
            # Get AI Foundry/Azure OpenAI credentials (AIServices is the new kind for AI Foundry)
            AZURE_OPENAI_NAME=$(az cognitiveservices account list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?kind=='AIServices' || kind=='OpenAI'].name | [0]" -o tsv)
            AZURE_OPENAI_KEY=""
            AZURE_OPENAI_ENDPOINT=""
            AZURE_OPENAI_DEPLOYMENT_NAME="gpt-4o"
            AZURE_OPENAI_AVAILABLE_MODELS=""
            USE_MANAGED_IDENTITY="true"
            if [ -n "$AZURE_OPENAI_NAME" ]; then
              AZURE_OPENAI_ENDPOINT=$(az cognitiveservices account show --name "$AZURE_OPENAI_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query "properties.endpoint" -o tsv)
              LOCAL_AUTH_DISABLED=$(az cognitiveservices account show --name "$AZURE_OPENAI_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query "properties.disableLocalAuth" -o tsv)
              if [ "$LOCAL_AUTH_DISABLED" == "true" ]; then
                USE_MANAGED_IDENTITY="true"
              else
                AZURE_OPENAI_KEY=$(az cognitiveservices account keys list --name "$AZURE_OPENAI_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query "key1" -o tsv 2>/dev/null || echo "")
              fi
              # Get available model deployments
              AZURE_OPENAI_AVAILABLE_MODELS=$(az cognitiveservices account deployment list --name "$AZURE_OPENAI_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query "[].name" -o tsv 2>/dev/null | tr '\n' ',' | sed 's/,$//')
              echo "  Azure OpenAI: $AZURE_OPENAI_NAME"
              echo "  Available Models: $AZURE_OPENAI_AVAILABLE_MODELS"
            fi
            
            # Get Azure Maps subscription key
            AZURE_MAPS_KEY=""
            MAPS_ACCOUNT=$(az maps account list --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv)
            if [ -n "$MAPS_ACCOUNT" ]; then
              AZURE_MAPS_KEY=$(az maps account keys list --name "$MAPS_ACCOUNT" --resource-group ${{ env.RESOURCE_GROUP }} --query "primaryKey" -o tsv)
              echo "  Azure Maps: $MAPS_ACCOUNT"
            fi
            
            # Update container with image AND refreshed environment variables
            az containerapp update \
              --name "$CA_NAME" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --image "${ACR_LOGIN_SERVER}/${{ env.PROJECT_NAME }}-api:${IMAGE_TAG}" \
              --set-env-vars \
                "PORT=8080" \
                "STAC_API_URL=https://planetarycomputer.microsoft.com/api/stac/v1" \
                "CORS_ORIGINS=*" \
                "AZURE_OPENAI_ENDPOINT=${AZURE_OPENAI_ENDPOINT}" \
                "AZURE_OPENAI_API_KEY=${AZURE_OPENAI_KEY}" \
                "AZURE_OPENAI_DEPLOYMENT_NAME=${AZURE_OPENAI_DEPLOYMENT_NAME}" \
                "AZURE_OPENAI_AVAILABLE_MODELS=${AZURE_OPENAI_AVAILABLE_MODELS}" \
                "USE_MANAGED_IDENTITY=${USE_MANAGED_IDENTITY}" \
                "AZURE_MAPS_SUBSCRIPTION_KEY=${AZURE_MAPS_KEY}" \
              --output none
            
            # Ensure ingress is configured with correct port
            echo "Ensuring ingress port is correct (8080)..."
            az containerapp ingress update \
              --name "$CA_NAME" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --target-port 8080 \
              --output none
              
            echo "Container App updated with refreshed credentials"
          else
            # Create new Container App
            echo "Creating new Container App..."
            CA_NAME="ca-${{ env.PROJECT_NAME }}-api"
            
            # Get AI Foundry endpoint (AIServices is the new kind for AI Foundry)
            AZURE_OPENAI_NAME=$(az cognitiveservices account list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?kind=='AIServices' || kind=='OpenAI'].name | [0]" -o tsv)
            AZURE_OPENAI_KEY=""
            AZURE_OPENAI_DEPLOYMENT_NAME="gpt-4o"
            AZURE_OPENAI_AVAILABLE_MODELS=""
            USE_MANAGED_IDENTITY="true"
            if [ -n "$AZURE_OPENAI_NAME" ]; then
              AZURE_OPENAI_ENDPOINT=$(az cognitiveservices account show --name "$AZURE_OPENAI_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query "properties.endpoint" -o tsv)
              # Check if local auth is disabled
              LOCAL_AUTH_DISABLED=$(az cognitiveservices account show --name "$AZURE_OPENAI_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query "properties.disableLocalAuth" -o tsv)
              if [ "$LOCAL_AUTH_DISABLED" == "true" ]; then
                echo "  INFO: Azure OpenAI has local auth disabled - will use managed identity"
                USE_MANAGED_IDENTITY="true"
              else
                AZURE_OPENAI_KEY=$(az cognitiveservices account keys list --name "$AZURE_OPENAI_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query "key1" -o tsv 2>/dev/null || echo "")
              fi
              # Get available model deployments
              AZURE_OPENAI_AVAILABLE_MODELS=$(az cognitiveservices account deployment list --name "$AZURE_OPENAI_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query "[].name" -o tsv 2>/dev/null | tr '\n' ',' | sed 's/,$//')
              echo "  Found Azure OpenAI: $AZURE_OPENAI_NAME"
              echo "  Available Models: $AZURE_OPENAI_AVAILABLE_MODELS"
            else
              AZURE_OPENAI_ENDPOINT=""
              echo "  WARNING: No Azure OpenAI found - app will use fallback settings"
            fi
            
            # Get Azure Maps subscription key
            AZURE_MAPS_KEY=""
            MAPS_ACCOUNT=$(az maps account list --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv)
            if [ -n "$MAPS_ACCOUNT" ]; then
              AZURE_MAPS_KEY=$(az maps account keys list --name "$MAPS_ACCOUNT" --resource-group ${{ env.RESOURCE_GROUP }} --query "primaryKey" -o tsv)
              echo "  Found Azure Maps: $MAPS_ACCOUNT"
            else
              echo "  WARNING: No Azure Maps account found"
            fi
            
            # STEP 1: Create Container App with a public placeholder image (no auth required)
            # This avoids the chicken-and-egg problem where we need managed identity to pull
            # from ACR, but managed identity doesn't exist until the app is created
            echo "Creating Container App with placeholder image..."
            az containerapp create \
              --name "$CA_NAME" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --environment "$CAE_NAME" \
              --image "mcr.microsoft.com/azuredocs/containerapps-helloworld:latest" \
              --target-port 8080 \
              --ingress external \
              --cpu 1.0 \
              --memory 2.0Gi \
              --min-replicas 1 \
              --max-replicas 3 \
              --system-assigned \
              --env-vars \
                "PORT=8080" \
                "STAC_API_URL=https://planetarycomputer.microsoft.com/api/stac/v1" \
                "CORS_ORIGINS=*" \
                "AZURE_OPENAI_ENDPOINT=${AZURE_OPENAI_ENDPOINT}" \
                "AZURE_OPENAI_API_KEY=${AZURE_OPENAI_KEY}" \
                "AZURE_OPENAI_DEPLOYMENT_NAME=${AZURE_OPENAI_DEPLOYMENT_NAME}" \
                "AZURE_OPENAI_AVAILABLE_MODELS=${AZURE_OPENAI_AVAILABLE_MODELS}" \
                "USE_MANAGED_IDENTITY=${USE_MANAGED_IDENTITY}" \
                "AZURE_MAPS_SUBSCRIPTION_KEY=${AZURE_MAPS_KEY}" \
              --output none
            
            echo "Container App created with placeholder image: $CA_NAME"
            
            # Ensure ingress target port matches the container app's port
            echo "Setting ingress target port to 8080..."
            az containerapp ingress update \
              --name "$CA_NAME" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --target-port 8080 \
              --output none
            
            echo "Ingress target port set to 8080"
            
            # STEP 2: Get the managed identity principal ID (now that app exists)
            CA_IDENTITY=$(az containerapp show --name "$CA_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query "identity.principalId" -o tsv)
            echo "Managed Identity Principal ID: $CA_IDENTITY"
            
            # STEP 3: Configure Azure OpenAI access if using managed identity
            if [ "$USE_MANAGED_IDENTITY" == "true" ] && [ -n "$AZURE_OPENAI_NAME" ]; then
              echo "Configuring managed identity for Azure OpenAI..."
              OPENAI_ID=$(az cognitiveservices account show --name "$AZURE_OPENAI_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query "id" -o tsv)
              
              az role assignment create \
                --assignee "$CA_IDENTITY" \
                --role "Cognitive Services OpenAI User" \
                --scope "$OPENAI_ID" \
                --output none 2>/dev/null || true
              
              echo "Managed identity configured for Azure OpenAI"
            fi
            
            # STEP 4: Grant AcrPull role to the Container App's managed identity
            echo "Configuring managed identity for ACR pull..."
            ACR_ID=$(az acr show --name "$ACR_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query "id" -o tsv)
            
            az role assignment create \
              --assignee "$CA_IDENTITY" \
              --role "AcrPull" \
              --scope "$ACR_ID" \
              --output none 2>/dev/null || true
            
            echo "AcrPull role assigned to managed identity"
            
            # STEP 5: Wait for role assignment to propagate (Azure RBAC can take up to 5 minutes)
            echo "Waiting 90 seconds for role assignment propagation..."
            sleep 90
            
            # STEP 6: Configure the registry to use managed identity
            echo "Configuring Container App to use managed identity for ACR..."
            az containerapp registry set \
              --name "$CA_NAME" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --server "$ACR_LOGIN_SERVER" \
              --identity system \
              --output none
            
            echo "Registry configured with managed identity"
            
            # STEP 7: Verify registry configuration before pulling
            echo "Verifying registry authentication configuration..."
            REGISTRY_CONFIG=$(az containerapp show \
              --name "$CA_NAME" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --query "properties.configuration.registries[?server=='${ACR_LOGIN_SERVER}'].identity" \
              -o tsv)
            
            if [ "$REGISTRY_CONFIG" != "system" ]; then
              echo "WARNING: Registry identity not set to 'system', retrying..."
              sleep 30
              az containerapp registry set \
                --name "$CA_NAME" \
                --resource-group "${{ env.RESOURCE_GROUP }}" \
                --server "$ACR_LOGIN_SERVER" \
                --identity system \
                --output none
            fi
            echo "Registry authentication verified: using system-assigned managed identity"
            
            # STEP 8: Verify managed identity has AcrPull role
            echo "Verifying AcrPull role assignment..."
            ROLE_EXISTS=$(az role assignment list \
              --assignee "$CA_IDENTITY" \
              --role "AcrPull" \
              --scope "$ACR_ID" \
              --query "[0].id" -o tsv 2>/dev/null || echo "")
            
            if [ -z "$ROLE_EXISTS" ]; then
              echo "WARNING: AcrPull role not found, waiting additional 60 seconds..."
              sleep 60
              # Retry role assignment
              az role assignment create \
                --assignee "$CA_IDENTITY" \
                --role "AcrPull" \
                --scope "$ACR_ID" \
                --output none 2>/dev/null || true
            fi
            echo "AcrPull role verified for managed identity"
            
            # STEP 9: Now update the Container App with the actual image from ACR
            echo "Updating Container App with actual image from ACR..."
            az containerapp update \
              --name "$CA_NAME" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --image "${ACR_LOGIN_SERVER}/${{ env.PROJECT_NAME }}-api:${IMAGE_TAG}" \
              --output none
            
            echo "Container App updated with image: ${ACR_LOGIN_SERVER}/${{ env.PROJECT_NAME }}-api:${IMAGE_TAG}"
          fi
          
          echo "container_app_name=$CA_NAME" >> $GITHUB_OUTPUT
          
          # Get URL
          CONTAINER_APP_URL=$(az containerapp show \
            --name "$CA_NAME" \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "properties.configuration.ingress.fqdn" -o tsv)
          
          echo "container_app_url=https://$CONTAINER_APP_URL" >> $GITHUB_OUTPUT
          echo "Backend deployed to: https://$CONTAINER_APP_URL"

  # Deploy Frontend via Azure Static Web Apps (no App Service VM quota needed)
  deploy-frontend:
    name: Deploy Frontend
    needs: [detect-changes, deploy-infrastructure, deploy-backend]
    if: |
      always() &&
      (needs.detect-changes.outputs.frontend == 'true' || needs.detect-changes.outputs.infra == 'true') &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped') &&
      (needs.deploy-backend.result == 'success' || needs.deploy-backend.result == 'skipped')
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment_name }}
    outputs:
      web_app_name: ${{ steps.deploy.outputs.static_web_app_name }}
      web_app_url: ${{ steps.deploy.outputs.static_web_app_url }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: earth-copilot/web-ui/package-lock.json

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get Backend URL
        id: get-backend-url
        run: |
          CA_NAME=$(az containerapp list --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv)
          if [ -z "$CA_NAME" ]; then
            echo "ERROR: No Container App found in ${{ env.RESOURCE_GROUP }}"
            exit 1
          fi
          CONTAINER_APP_URL=$(az containerapp show \
            --name "$CA_NAME" \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "properties.configuration.ingress.fqdn" -o tsv)
          echo "backend_url=https://$CONTAINER_APP_URL" >> $GITHUB_OUTPUT
          echo "  Backend URL: https://$CONTAINER_APP_URL"

      - name: Get Azure Maps Key
        id: get-maps-key
        run: |
          MAPS_ACCOUNT=$(az maps account list \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "[0].name" -o tsv)
          
          if [ -n "$MAPS_ACCOUNT" ]; then
            MAPS_KEY=$(az maps account keys list \
              --name "$MAPS_ACCOUNT" \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query "primaryKey" -o tsv)
            echo "maps_key=$MAPS_KEY" >> $GITHUB_OUTPUT
            echo "Azure Maps key retrieved from: $MAPS_ACCOUNT"
          else
            echo "WARNING: No Azure Maps account found in ${{ env.RESOURCE_GROUP }}"
            echo "maps_key=" >> $GITHUB_OUTPUT
          fi

      - name: Build Frontend
        run: |
          cd earth-copilot/web-ui
          npm ci
          VITE_API_BASE_URL="${{ steps.get-backend-url.outputs.backend_url }}" \
          VITE_AZURE_MAPS_SUBSCRIPTION_KEY="${{ steps.get-maps-key.outputs.maps_key }}" \
          npm run build

      - name: Create or Discover Static Web App
        id: deploy
        run: |
          echo "Deploying frontend as Azure Static Web App..."
          
          SWA_NAME="swa-${{ env.PROJECT_NAME }}"
          
          # Check if SWA already exists
          SWA_EXISTS=$(az staticwebapp list --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "[?name=='$SWA_NAME'].name" -o tsv 2>/dev/null || true)
          
          if [ -z "$SWA_EXISTS" ]; then
            echo "Creating Static Web App: $SWA_NAME"
            az staticwebapp create \
              --name "$SWA_NAME" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --location "${{ env.LOCATION }}" \
              --sku Free \
              --output none
            echo "  Created Static Web App: $SWA_NAME"
          else
            echo "  Static Web App already exists: $SWA_NAME"
          fi
          
          # Get deployment token
          DEPLOYMENT_TOKEN=$(az staticwebapp secrets list \
            --name "$SWA_NAME" \
            --resource-group "${{ env.RESOURCE_GROUP }}" \
            --query "properties.apiKey" -o tsv)
          
          echo "deployment_token=$DEPLOYMENT_TOKEN" >> $GITHUB_OUTPUT
          echo "static_web_app_name=$SWA_NAME" >> $GITHUB_OUTPUT
          
          # Get the URL
          SWA_URL=$(az staticwebapp show \
            --name "$SWA_NAME" \
            --resource-group "${{ env.RESOURCE_GROUP }}" \
            --query "defaultHostname" -o tsv)
          echo "static_web_app_url=https://$SWA_URL" >> $GITHUB_OUTPUT
          echo "  Static Web App URL: https://$SWA_URL"

      - name: Deploy to Static Web App
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ steps.deploy.outputs.deployment_token }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: "upload"
          app_location: "earth-copilot/web-ui/dist"
          skip_app_build: true
          skip_api_build: true

  # Enable Azure AI Agent Service (required for GEOINT agents)
  # -----------------------------------------------------------------------------
  # Enables Agent Service capability hosts on the AI Foundry account so that
  # GEOINT agents (Vision, Terrain, Mobility, Building Damage, Comparison,
  # Extreme Weather) can use multi-turn tool orchestration.
  #
  # The Router Agent works immediately (Semantic Kernel + Azure OpenAI),
  # but all specialized GEOINT agents require Agent Service to function.
  #
  # This job:
  #   1. Enables allowProjectManagement on the CogSvc account
  #   2. Creates a CogSvc project sub-resource
  #   3. Creates account-level and project-level capability hosts (Agents)
  #   4. Assigns required roles to the Container App's managed identity
  #   5. Updates AZURE_AI_PROJECT_ENDPOINT env var on the Container App
  # -----------------------------------------------------------------------------
  enable-agent-service:
    name: Enable Agent Service
    needs: [deploy-backend]
    if: needs.deploy-backend.result == 'success'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment_name }}
    outputs:
      agent_service_enabled: ${{ steps.enable.outputs.agent_service_enabled }}
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Enable Agent Service
        id: enable
        run: |
          set -euo pipefail

          API_VERSION="2025-04-01-preview"
          PROJECT_NAME="earth-copilot-agents"

          # -- Discover resources --
          SUBSCRIPTION_ID=$(az account show --query id -o tsv)
          echo "Subscription: $SUBSCRIPTION_ID"

          ACCOUNT_NAME=$(az cognitiveservices account list \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "[?kind=='AIServices'].name | [0]" -o tsv)
          if [ -z "$ACCOUNT_NAME" ]; then
            echo "ERROR: No AIServices account found in ${{ env.RESOURCE_GROUP }}"
            echo "Agent Service cannot be enabled without AI Foundry."
            exit 1
          fi
          echo "AI Foundry account: $ACCOUNT_NAME"

          CA_NAME=$(az containerapp list \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "[0].name" -o tsv)
          if [ -z "$CA_NAME" ]; then
            echo "ERROR: No Container App found in ${{ env.RESOURCE_GROUP }}"
            exit 1
          fi
          echo "Container App: $CA_NAME"

          BASE_URL="https://management.azure.com/subscriptions/$SUBSCRIPTION_ID/resourceGroups/${{ env.RESOURCE_GROUP }}/providers/Microsoft.CognitiveServices/accounts/$ACCOUNT_NAME"

          # -- Helper: wait for provisioning --
          wait_for_provisioning() {
            local url="$1"
            local timeout="${2:-120}"
            local elapsed=0
            while [ $elapsed -lt $timeout ]; do
              sleep 10
              elapsed=$((elapsed + 10))
              state=$(az rest --method get \
                --url "${url}?api-version=${API_VERSION}" \
                --query "properties.provisioningState" -o tsv 2>/dev/null || echo "Unknown")
              echo "  State: $state (${elapsed}s)"
              if [ "$state" == "Succeeded" ]; then return 0; fi
              if [ "$state" == "Failed" ]; then echo "ERROR: Provisioning failed"; return 1; fi
            done
            echo "ERROR: Provisioning timed out after ${timeout}s"
            return 1
          }

          # -- Step 1: Enable allowProjectManagement --
          echo ""
          echo "=== Step 1: Enable allowProjectManagement ==="
          
          # Detect current publicNetworkAccess state so we don't undo PE lockdown
          CURRENT_PNA=$(az cognitiveservices account show \
            --name "$ACCOUNT_NAME" --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "properties.publicNetworkAccess" -o tsv 2>/dev/null || echo "Enabled")
          echo "  Current publicNetworkAccess: $CURRENT_PNA"
          
          if [ "$CURRENT_PNA" == "Disabled" ]; then
            NETWORK_ACTION="Deny"
          else
            NETWORK_ACTION="Allow"
          fi
          
          BODY=$(cat <<EOF
          {
            "location": "${{ env.LOCATION }}",
            "kind": "AIServices",
            "sku": { "name": "S0" },
            "identity": { "type": "SystemAssigned" },
            "properties": {
              "allowProjectManagement": true,
              "customSubDomainName": "$ACCOUNT_NAME",
              "publicNetworkAccess": "$CURRENT_PNA",
              "disableLocalAuth": true,
              "networkAcls": { "defaultAction": "$NETWORK_ACTION" }
            }
          }
          EOF
          )
          az rest --method put \
            --url "${BASE_URL}?api-version=${API_VERSION}" \
            --body "$BODY" \
            --query "properties.allowProjectManagement" -o tsv 2>&1 || true
          wait_for_provisioning "$BASE_URL"
          echo "  allowProjectManagement enabled"

          # -- Step 2: Create CogSvc project sub-resource --
          echo ""
          echo "=== Step 2: Create CogSvc project '$PROJECT_NAME' ==="
          PROJECT_URL="${BASE_URL}/projects/${PROJECT_NAME}"
          PROJECT_BODY=$(cat <<EOF
          {
            "location": "${{ env.LOCATION }}",
            "identity": { "type": "SystemAssigned" },
            "properties": {
              "description": "Earth Copilot GEOINT Agent Project",
              "displayName": "Earth Copilot Agents"
            }
          }
          EOF
          )
          result=$(az rest --method put \
            --url "${PROJECT_URL}?api-version=${API_VERSION}" \
            --body "$PROJECT_BODY" \
            --query "properties.provisioningState" -o tsv 2>&1 || echo "Unknown")
          echo "  Project state: $result"
          if [ "$result" != "Succeeded" ]; then
            wait_for_provisioning "$PROJECT_URL"
          fi

          # -- Step 3: Create account-level capability host --
          echo ""
          echo "=== Step 3: Create account capability host ==="
          ACCT_CAP_URL="${BASE_URL}/capabilityHosts/default"
          az rest --method put \
            --url "${ACCT_CAP_URL}?api-version=${API_VERSION}" \
            --body '{"properties":{"capabilityHostKind":"Agents"}}' \
            --query "properties.provisioningState" -o tsv 2>&1 || true
          wait_for_provisioning "$ACCT_CAP_URL"
          echo "  Account capability host created"

          # -- Step 4: Create project-level capability host --
          echo ""
          echo "=== Step 4: Create project capability host ==="
          PROJ_CAP_URL="${PROJECT_URL}/capabilityHosts/default"
          az rest --method put \
            --url "${PROJ_CAP_URL}?api-version=${API_VERSION}" \
            --body '{"properties":{"capabilityHostKind":"Agents"}}' \
            --query "properties.provisioningState" -o tsv 2>&1 || true
          wait_for_provisioning "$PROJ_CAP_URL"
          echo "  Project capability host created"

          # -- Step 5: Assign roles to Container App managed identity --
          echo ""
          echo "=== Step 5: Assign roles to Container App MI ==="
          PRINCIPAL_ID=$(az containerapp show \
            -n "$CA_NAME" -g ${{ env.RESOURCE_GROUP }} \
            --query "identity.principalId" -o tsv)
          echo "  MI Principal ID: $PRINCIPAL_ID"

          SCOPE="/subscriptions/$SUBSCRIPTION_ID/resourceGroups/${{ env.RESOURCE_GROUP }}/providers/Microsoft.CognitiveServices/accounts/$ACCOUNT_NAME"

          for ROLE in "Azure AI User" "Cognitive Services OpenAI Contributor"; do
            echo "  Assigning: $ROLE"
            az role assignment create \
              --assignee-object-id "$PRINCIPAL_ID" \
              --assignee-principal-type ServicePrincipal \
              --role "$ROLE" \
              --scope "$SCOPE" \
              -o none 2>/dev/null || echo "  (already assigned or insufficient permissions)"
          done

          # -- Step 6: Update AZURE_AI_PROJECT_ENDPOINT env var --
          echo ""
          echo "=== Step 6: Update AZURE_AI_PROJECT_ENDPOINT ==="
          ENDPOINT="https://${ACCOUNT_NAME}.services.ai.azure.com/api/projects/${PROJECT_NAME}"
          echo "  Endpoint: $ENDPOINT"
          az containerapp update \
            -n "$CA_NAME" -g ${{ env.RESOURCE_GROUP }} \
            --set-env-vars "AZURE_AI_PROJECT_ENDPOINT=$ENDPOINT" \
            -o none 2>/dev/null || true

          echo ""
          echo "Agent Service enabled successfully"
          echo "agent_service_enabled=true" >> $GITHUB_OUTPUT

  # Configure Entra ID Authentication (runs after frontend deployment)
  # -----------------------------------------------------------------------------
  # Optional: Configure Microsoft Entra ID authentication on the frontend
  #
  # Prerequisites (set in GitHub Environment "dev"):
  #   Secret:   AUTH_CLIENT_ID       — Entra app registration Client ID (optional — auto-created if not set)
  #   Variable: AUTH_AUTHORIZED_USERS — Comma-separated UPNs (e.g. "user@org.com,user2@org.com")
  #
  # No hardcoded tenant IDs, client IDs, or domain names — all values are
  # discovered dynamically from the Azure subscription or read from secrets/vars.
  #
  # If AUTH_CLIENT_ID is not set, this job is skipped and the app remains public.
  # See QUICK_DEPLOY.md for setup instructions.
  # -----------------------------------------------------------------------------
  configure-auth:
    name: Configure Entra ID Auth
    needs: [deploy-frontend]
    if: needs.deploy-frontend.result == 'success'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment_name }}
    outputs:
      auth_configured: ${{ steps.auth.outputs.auth_configured }}
    steps:
      - name: Check auth prerequisites
        id: check
        run: |
          DISABLE_AUTH="${{ github.event.inputs.disable_auth }}"
          HAS_CLIENT_ID="false"
          if [ -n "${{ secrets.AUTH_CLIENT_ID }}" ]; then
            HAS_CLIENT_ID="true"
          fi

          # Auth is ON by default; only skipped if user explicitly checks disable_auth
          if [ "$DISABLE_AUTH" == "true" ]; then
            echo "mode=skip" >> $GITHUB_OUTPUT
            echo "Auth explicitly disabled — app will be publicly accessible"
          elif [ "$HAS_CLIENT_ID" == "true" ]; then
            echo "mode=existing" >> $GITHUB_OUTPUT
            echo "Using existing app registration from AUTH_CLIENT_ID secret"
          else
            echo "mode=create" >> $GITHUB_OUTPUT
            echo "AUTH_CLIENT_ID not set — will auto-create app registration"
          fi

      - name: Azure Login
        if: steps.check.outputs.mode != 'skip'
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Configure Entra ID Authentication
        id: auth
        if: steps.check.outputs.mode != 'skip'
        env:
          AUTH_MODE: ${{ steps.check.outputs.mode }}
          AUTH_CLIENT_ID: ${{ secrets.AUTH_CLIENT_ID }}
          AUTH_AUTHORIZED_USERS: ${{ vars.AUTH_AUTHORIZED_USERS }}
        run: |
          set -euo pipefail

          # -- Discover Static Web App --
          SWA_NAME=$(az staticwebapp list --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv)
          if [ -z "$SWA_NAME" ]; then
            echo "ERROR: No Static Web App found in ${{ env.RESOURCE_GROUP }}"
            exit 1
          fi

          WEB_URL="https://$(az staticwebapp show --name "$SWA_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query defaultHostname -o tsv)"
          REDIRECT_URI="${WEB_URL}/.auth/login/aad/callback"
          TENANT_ID=$(az account show --query tenantId -o tsv)

          echo "Static Web App: $SWA_NAME"
          echo "URL: $WEB_URL"
          echo "Tenant: $TENANT_ID"

          # -- Resolve or create app registration --
          if [ "$AUTH_MODE" == "existing" ]; then
            CLIENT_ID="$AUTH_CLIENT_ID"
            echo "Using existing app registration: $CLIENT_ID"

            # Update redirect URI on existing app
            az ad app update --id "$CLIENT_ID" \
              --web-redirect-uris "$REDIRECT_URI" 2>/dev/null || \
              echo "WARNING: Could not update redirect URI (SP may lack permission — update manually in Entra portal)"
          else
            # Auto-create app registration
            # NOTE: This requires the service principal to have Microsoft Graph
            # Application.ReadWrite.OwnedBy (or Application.ReadWrite.All) permission.
            # A default "az ad sp create-for-rbac --role contributor" SP does NOT have this.
            APP_DISPLAY_NAME="${{ env.PROJECT_NAME }}-Auth"
            echo "Creating Entra ID app registration: $APP_DISPLAY_NAME"
            APP_JSON=$(az ad app create \
              --display-name "$APP_DISPLAY_NAME" \
              --sign-in-audience AzureADMyOrg \
              --web-redirect-uris "$REDIRECT_URI" \
              --required-resource-accesses '[{"resourceAppId":"00000003-0000-0000-c000-000000000000","resourceAccess":[{"id":"e1fe6dd8-ba31-4d61-89e7-88639da4683d","type":"Scope"},{"id":"37f7f235-527c-4136-accd-4a02d197296e","type":"Scope"},{"id":"7427e0e9-2fba-42fe-b0c0-848c9e6a8182","type":"Scope"}]}]' \
              -o json 2>&1) || {
              echo ""
              echo "================================================================="
              echo "WARNING: Could not auto-create app registration."
              echo ""
              echo "Your service principal likely lacks Microsoft Graph permissions."
              echo "Infrastructure, backend, and frontend deployed successfully."
              echo ""
              echo "To enable auth, choose one of:"
              echo ""
              echo "  Option 1: Create the app registration manually in Azure Portal"
              echo "    -> https://portal.azure.com/#view/Microsoft_AAD_RegisteredApps/ApplicationsListBlade"
              echo "    -> Then save: gh secret set AUTH_CLIENT_ID --env dev --body \"<CLIENT_ID>\""
              echo ""
              echo "  Option 2: Grant your SP the Graph permission and re-run"
              echo "    -> az ad app permission add --id <SP_APP_ID> --api 00000003-0000-0000-c000-000000000000 --api-permissions 18a4783c-866b-4cc7-a460-3d5e5662c884=Role"
              echo "    -> az ad app permission admin-consent --id <SP_APP_ID>"
              echo ""
              echo "  Option 3: Run the local script instead"
              echo "    -> .\\scripts\\enable-webapp-auth.ps1 -ResourceGroupName ${{ env.RESOURCE_GROUP }}"
              echo "================================================================="
              echo ""
              echo "Deployment succeeded — app is accessible at: $WEB_URL (without auth)"
              exit 0
            }
            CLIENT_ID=$(echo "$APP_JSON" | jq -r '.appId')
            if [ -z "$CLIENT_ID" ] || [ "$CLIENT_ID" == "null" ]; then
              echo "WARNING: App registration created but could not parse Client ID"
              echo "Deployment succeeded — app is accessible at: $WEB_URL (without auth)"
              exit 0
            fi
            echo "Created app registration: $CLIENT_ID"
            echo ""
            echo "===================================================================="
            echo "SAVE THIS: Add AUTH_CLIENT_ID as a GitHub secret so future deploys"
            echo "reuse this app registration instead of creating a new one:"
            echo ""
            echo "  gh secret set AUTH_CLIENT_ID --env dev --body \"$CLIENT_ID\""
            echo ""
            echo "===================================================================="
            echo ""
          fi

          # -- Ensure service principal exists --
          SP_ID=$(az ad sp show --id "$CLIENT_ID" --query id -o tsv 2>/dev/null || true)
          if [ -z "$SP_ID" ]; then
            SP_ID=$(az ad sp create --id "$CLIENT_ID" --query id -o tsv 2>/dev/null || true)
            if [ -z "$SP_ID" ]; then
              echo "WARNING: Could not find or create service principal for $CLIENT_ID"
              echo "EasyAuth will still work but user-level restrictions require manual setup."
              echo "Deployment succeeded — app is accessible at: $WEB_URL"
              exit 0
            fi
            echo "Created service principal: $SP_ID"
          else
            echo "Service principal exists: $SP_ID"
          fi

          # -- Configure EasyAuth on the Static Web App --
          # SWA auth is configured via staticwebapp.config.json in the app source.
          # For Entra ID, we register the app and output instructions.
          echo "NOTE: Static Web Apps use staticwebapp.config.json for auth configuration."
          echo "To enable Entra ID auth, add an 'auth' section to staticwebapp.config.json"
          echo "or configure it in the Azure Portal under the Static Web App's Authentication settings."
          echo ""
          echo "App Registration Client ID: $CLIENT_ID"
          echo "Tenant ID: $TENANT_ID"
          echo "Redirect URI: $REDIRECT_URI"
          echo ""
          echo "Authentication app registration ready"
          echo "URL: $WEB_URL"
          echo "auth_configured=true" >> $GITHUB_OUTPUT

  # Summary
  summary:
    name: Deployment Summary
    needs: [detect-changes, deploy-infrastructure, deploy-backend, deploy-frontend, enable-agent-service, configure-auth]
    if: always()
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment_name }}
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Generate Summary
        run: |
          echo "# Earth Copilot Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## Components Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "| Component | Changed | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|---------|--------|" >> $GITHUB_STEP_SUMMARY
          
          # Infrastructure
          if [ "${{ needs.detect-changes.outputs.infra }}" == "true" ]; then
            if [ "${{ needs.deploy-infrastructure.result }}" == "success" ]; then
              echo "| Infrastructure | Yes | Deployed |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Infrastructure | Yes | Failed |" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "| Infrastructure | No | Skipped |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Backend
          if [ "${{ needs.detect-changes.outputs.backend }}" == "true" ] || [ "${{ needs.detect-changes.outputs.infra }}" == "true" ]; then
            if [ "${{ needs.deploy-backend.result }}" == "success" ]; then
              echo "| Backend | Yes | Deployed |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Backend | Yes | Failed |" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "| Backend | No | Skipped |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Frontend
          if [ "${{ needs.detect-changes.outputs.frontend }}" == "true" ] || [ "${{ needs.detect-changes.outputs.infra }}" == "true" ]; then
            if [ "${{ needs.deploy-frontend.result }}" == "success" ]; then
              echo "| Frontend | Yes | Deployed |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Frontend | Yes | Failed |" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "| Frontend | No | Skipped |" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Endpoints" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Discover actual resource names and URLs
          SWA_NAME=$(az staticwebapp list --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv 2>/dev/null || echo "")
          CA_NAME=$(az containerapp list --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv 2>/dev/null || echo "")
          
          if [ -n "$SWA_NAME" ]; then
            WEB_URL=$(az staticwebapp show --name "$SWA_NAME" --resource-group ${{ env.RESOURCE_GROUP }} --query "defaultHostname" -o tsv)
            echo "- **Frontend (SWA)**: https://$WEB_URL" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Frontend**: Not deployed yet" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ -n "$CA_NAME" ]; then
            CA_URL=$(az containerapp show --resource-group ${{ env.RESOURCE_GROUP }} --name "$CA_NAME" --query "properties.configuration.ingress.fqdn" -o tsv)
            echo "- **Backend API**: https://$CA_URL" >> $GITHUB_STEP_SUMMARY
            echo "- **API Docs**: https://$CA_URL/docs" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Backend**: Not deployed yet" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Authentication" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.configure-auth.outputs.auth_configured }}" == "true" ]; then
            echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Mode | Microsoft Entra ID (Single Tenant) |" >> $GITHUB_STEP_SUMMARY
            echo "| Access | Restricted to assigned users |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.configure-auth.result }}" == "skipped" ]; then
            echo "Auth was explicitly disabled. To enable, re-run without **disable_auth** or set \`AUTH_CLIENT_ID\` secret." >> $GITHUB_STEP_SUMMARY
          else
            echo "Auth not configured — check workflow logs for instructions on enabling authentication." >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Agent Service (GEOINT)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.enable-agent-service.outputs.agent_service_enabled }}" == "true" ]; then
            echo "Agent Service enabled — all GEOINT agents (Vision, Terrain, Mobility, Building Damage, Comparison, Extreme Weather) are ready." >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.enable-agent-service.result }}" == "skipped" ]; then
            echo "Agent Service skipped (backend did not deploy). Run the workflow with \`force_all\` to enable." >> $GITHUB_STEP_SUMMARY
          else
            echo "Agent Service enablement failed — GEOINT agents will not function. Check workflow logs or run manually: \`./scripts/enable-agent-service.ps1\`" >> $GITHUB_STEP_SUMMARY
          fi
