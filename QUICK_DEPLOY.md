# Quick Deploy - Earth Copilot (GitHub Actions)

**Full automated deployment to Azure via GitHub Actions**

Deploy Earth Copilot to your Azure subscription with full automation. This workflow deploys all infrastructure, backend, and frontend in < 1 hour.

### What Gets Deployed

Earth Copilot is a multi-agent geospatial AI system powered by **Azure AI Agent Service** and **Semantic Kernel**.

The infrastructure includes Azure AI Foundry (with GPT model deployment of your choice + Agent Service Hub/Project), Container Apps, Azure Maps, Container Registry (with VNet-integrated build agent pool), Key Vault, and Storage.


## Deployment Overview

These instructions work for any Azure subscription:

| Aspect | Value | Who Provides It |
|--------|-------|-----------------|
| Source repo to fork | `microsoft/Earth-Copilot` | OSS |
| Azure subscription | User's own | User |
| Service principal | Created by user | User |
| GitHub secret | `AZURE_CREDENTIALS` | User |
| Resource group | `rg-earthcopilot` (default) | Workflow (`vars.RESOURCE_GROUP`) |
| Location | `eastus2` (default) | Workflow (`vars.LOCATION`) |
| Project name prefix | `earthcopilot` (default) | Workflow (`vars.PROJECT_NAME`) |
| Resource names | Auto-generated unique | Workflow (dynamic) |
| Private endpoints | **ON** by default | Workflow (opt-out: `disable_private_endpoints`) |
| Authentication | **ON** by default (Entra ID) | Workflow (opt-out: `disable_auth`) |

---

## What You'll Need

- **Azure Account**: Active Azure subscription
- **GitHub Account**: To fork this repository
- **Azure CLI**: Required for Azure authentication and resource provider registration ([Install in Step 3](#step-3-install-required-cli-tools))
- **GitHub CLI**: Optional but recommended for easier secret configuration ([Install in Step 3](#step-3-install-required-cli-tools))

### Required Azure Permissions

You need these permissions (all configured manually before deploying):

| Permission Type | Required Role | Purpose | Required? |
|-----------------|---------------|---------|-----------|
| **Azure AD** | "Users can register applications" = Yes (default) OR **Application Developer** role | Create service principal (Step 7) | **Yes** |
| **Azure Subscription** | **Contributor** + **User Access Administrator** | Deploy resources + assign roles | **Yes** |

---

## Step 1: Fork the Repository

1. Go to: https://github.com/microsoft/Earth-Copilot
2. Click the **"Fork"** button at the top right
3. Choose your GitHub account as the destination
4. Wait for the fork to complete (~10 seconds)

> **Why fork instead of clone?** Forking creates your own copy of the repository where you can store GitHub Secrets and run GitHub Actions workflows. You cannot add secrets or trigger workflows on the original Microsoft repository.

**You now have your own copy of Earth Copilot!**

---

## Step 2: Clone and Open in VS Code

```powershell
# Clone your fork
git clone https://github.com/YOUR-USERNAME/Earth-Copilot.git
cd Earth-Copilot

# Open in VS Code
code .
```

Replace `YOUR-USERNAME` with your GitHub username.

---

## Step 3: Install Required CLI Tools

### Azure CLI

**Windows**:
```powershell
winget install Microsoft.AzureCLI
```

**macOS**:
```bash
brew install azure-cli
```

**Linux**:
```bash
curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
```

Restart your terminal and verify:
```powershell
az --version
```

### GitHub CLI (Optional but Recommended)

The GitHub CLI makes it easier to configure secrets, trigger deployments, and monitor workflows.

**Windows**:
```powershell
winget install GitHub.cli
```

**macOS**:
```bash
brew install gh
```

**Linux**:
```bash
# Debian/Ubuntu
curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
sudo apt update && sudo apt install gh
```

Restart your terminal and authenticate:
```powershell
gh --version
gh auth login
```

Follow the prompts to authenticate with your GitHub account.

---

## Step 4: Authenticate to Azure

```powershell
# Authenticate with Azure CLI (opens browser)
az login

# Verify you're using the correct subscription
az account show --query "{Name:name, SubscriptionId:id, TenantId:tenantId}" -o table

# If you have multiple subscriptions, set the correct one:
az account set --subscription "YOUR-SUBSCRIPTION-ID"

# If you have multiple tenants and need a specific one:
az login --tenant YOUR-TENANT-ID
```

---

## Step 5: Open GitHub Copilot in Agent Mode (Recommended)

For an AI-assisted deployment experience, use **GitHub Copilot Agent Mode** in VS Code:

1. Press `Ctrl+Shift+I` (Windows/Linux) or `Cmd+Shift+I` (macOS) to open Copilot Chat
2. Click the **Agent Mode** toggle (or type `@workspace` to start)
3. Ask Copilot to help with deployment:
   ```
   Help me deploy Earth Copilot to Azure following QUICK_DEPLOY.md
   ```

![VS Code Agent Mode](documentation/images/vsc_agentmode.png)

> **Tip**: Let Copilot guide you through the remaining steps.

---

## Step 6: Register Azure Resource Providers (One-Time Setup)

**Required for Container Apps, AI services, and Agent Service.**

```bash
# Register required resource providers
az provider register --namespace Microsoft.App
az provider register --namespace Microsoft.ContainerService
az provider register --namespace Microsoft.CognitiveServices
az provider register --namespace Microsoft.Maps
az provider register --namespace Microsoft.MachineLearningServices   # Required for AI Foundry Hub/Project (Agent Service)

# Verify registration (should show "Registered")
az provider show --namespace Microsoft.App --query "registrationState"
az provider show --namespace Microsoft.MachineLearningServices --query "registrationState"
```

**This takes 2-3 minutes.** Wait for all to show "Registered" before proceeding.

---

## Step 7: Create Service Principal (One-Time Setup)

**This gives GitHub Actions permission to deploy to your Azure subscription.**

> If you verified your permissions in the "What You'll Need" section above, you're ready to proceed.

### Create the Service Principal

```powershell
# Get your subscription ID
$subscriptionId = az account show --query id -o tsv

# Create service principal with Contributor role
az ad sp create-for-rbac `
  --name "sp-earthcopilot-dev" `
  --role Contributor `
  --scopes /subscriptions/$subscriptionId `
  --json-auth

# IMPORTANT: Copy the JSON output above - you'll need it for GitHub secrets!

# Also grant User Access Administrator role (required for role assignments)
$appId = az ad sp list --display-name "sp-earthcopilot-dev" --query "[0].appId" -o tsv
az role assignment create `
  --assignee $appId `
  --role "User Access Administrator" `
  --scope /subscriptions/$subscriptionId
```

**Important**: Copy the entire JSON output from the first command (from `{` to `}`). You'll need this in Step 8.

**Keep this secret safe!** Don't commit it to Git or share it publicly.

**Why two roles?**
- **Contributor**: Deploys Azure resources (Container Apps, Key Vault, etc.)
- **User Access Administrator**: Creates role assignments (ACR pull permissions, Key Vault access)

---

## Step 8: Configure GitHub Environment

### Option A: GitHub CLI (Recommended - Fastest)

Use the GitHub CLI to configure the environment and secret:

```powershell
# Navigate to your cloned repo
cd Earth-Copilot

# Create the dev environment (replace YOUR-USERNAME with your GitHub username)
gh api repos/YOUR-USERNAME/Earth-Copilot/environments/dev -X PUT

# Set the service principal secret
gh secret set AZURE_CREDENTIALS --env dev
# When prompted, paste the entire JSON output from Step 7, then press Ctrl+Z
```

### Option B: GitHub Web UI

**8.1 Create Environment**
1. Go to your forked repo on GitHub
2. Click **Settings** tab → **Environments** (left sidebar)
3. Click **New environment**
4. Name: `dev`
5. Click **Configure environment**

**8.2 Add Service Principal Secret**

Use the JSON output from **Step 7** (the service principal you created).

1. Scroll to **Environment secrets**
2. Click **Add secret**
3. Name: `AZURE_CREDENTIALS`
4. Value: Paste the **entire JSON** from Step 7 (including curly braces)
5. Click **Add secret**

The JSON should look like this:
```json
{
  "clientId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
  "clientSecret": "your-secret-here",
  "subscriptionId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
  "tenantId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
  ...
}
```

> **Note:** The workflow automatically discovers resource names at runtime. To customize defaults, set GitHub Environment variables (`vars.RESOURCE_GROUP`, `vars.LOCATION`, `vars.PROJECT_NAME`) in Settings → Environments → dev. No workflow file edits needed.

---

## Step 9: Deploy via GitHub Actions

**Now the automated part begins!** The default deployment is **fully locked down** — private endpoints + Entra ID authentication.

### Option A: GitHub CLI (Recommended)

```powershell
# Trigger deployment — fully locked down by default (private endpoints + auth)
gh workflow run deploy.yml -f force_all=true

# Watch the workflow run
gh run watch
```

### Option B: GitHub Web UI

1. Go to your forked repository on GitHub
2. Click the **Actions** tab
3. Select **"Deploy Earth Copilot"** workflow
4. Click **"Run workflow"** button
5. Check **"Force deploy all components"** to deploy everything
6. Click **"Run workflow"**

> CI/CD deployments always work (they use the ARM management plane). For local development against private services, you need a VPN gateway or Azure Bastion.

---

## Step 10: Monitor Deployment

**Expected deployment time**: 10-15 minutes

```powershell
# Watch the workflow run (if using GitHub CLI)
gh run watch

# Or view in browser
gh run list --workflow=deploy.yml
```

The workflow runs these jobs:
1. **Detect Changes** — Determines which components need deployment (or deploys all if `force_all=true`)
2. **Deploy Infrastructure** — All Azure resources including AI Foundry (model of your choice + Agent Service Hub/Project), Container Apps Environment, ACR, Azure Maps, Key Vault, Storage, Log Analytics, VNet + Private Endpoints
3. **Deploy Backend** — Container App with FastAPI + all agents (Router, Vision, Terrain, Mobility, Building Damage, Comparison, Extreme Weather) + automatic credential configuration via managed identity
4. **Deploy Frontend** — App Service with React UI (includes GEOINT module selectors for Terrain, Mobility, Extreme Weather, Building Damage, and Comparison)
5. **Enable Agent Service** — Enables Agent Service capability hosts on AI Foundry so GEOINT agents can use multi-turn tool orchestration (fallback: `scripts\enable-agent-service.ps1`)
6. **Configure Auth** — Auto-creates Entra ID app registration and configures EasyAuth (gracefully skips if SP lacks Graph permissions)
7. **Summary** — Prints deployment status, endpoints, auth configuration, and Agent Service status

![GitHub Actions Auto Deploy](documentation/images/auto_deploy_github_actions.png)
**Example Resource Group:**

![Azure Resource Group](documentation/images/resources.png)

**Example Azure AI Foundry Deployment:**

![Azure AI Foundry Deployment](documentation/images/foundry.png)

---

## Step 11: Access Your Application

After deployment completes, you can find your application URLs in multiple ways:

### Option 1: GitHub Workflow Summary (Easiest)

1. Go to your repository → **Actions** tab
2. Click on the completed **"Deploy Earth Copilot"** workflow run
3. Scroll down to the **"Deployment Summary"** at the bottom
4. You'll see:
   - **Frontend URL**: `https://app-earthcopilot-ui.azurewebsites.net`
   - **Backend API**: `https://ca-earthcopilot-api.{region}.azurecontainerapps.io`
   - **API Docs**: `https://ca-earthcopilot-api.{region}.azurecontainerapps.io/docs`

### Option 2: Azure Portal

1. Go to [Azure Portal](https://portal.azure.com)
2. Navigate to your resource group: `rg-earthcopilot`
3. Find the **App Service** (name starts with `app-`)
4. Click on it → the **URL** is shown at the top right

### Option 3: Azure CLI

```powershell
# Get frontend URL
az webapp show --name (az webapp list --resource-group rg-earthcopilot --query "[0].name" -o tsv) --resource-group rg-earthcopilot --query "defaultHostName" -o tsv

# Get backend URL
az containerapp show --name (az containerapp list --resource-group rg-earthcopilot --query "[0].name" -o tsv) --resource-group rg-earthcopilot --query "properties.configuration.ingress.fqdn" -o tsv
```

**Your Earth Copilot is now live!** Open the frontend URL and click **Get Started** to try sample searches. The rest of the steps in this guide are optional.

![Get Started](documentation/images/get_started.png)

---

## Step 12 (Optional): Configure Authorized Users

Authentication is **enabled by default** — the deployment automatically creates an Entra ID app registration and configures EasyAuth. All users in your tenant can sign in.

> **First-time deployers**: The auto-create requires your service principal to have Microsoft Graph `Application.ReadWrite.OwnedBy` permission. If it doesn't (the default `az ad sp create-for-rbac --role contributor` SP doesn't), the workflow will print clear instructions and **succeed gracefully** — your app deploys without auth. See the options below to enable auth afterwards.

To restrict access to specific users, set the `AUTH_AUTHORIZED_USERS` variable before deploying:

```powershell
# Comma-separated list of user principal names (UPNs)
gh variable set AUTH_AUTHORIZED_USERS --env dev --body "user1@yourdomain.com,user2@yourdomain.com"
```


### Alternative: Local Script (One-Time Setup)

```powershell
$webAppName = az webapp list --resource-group rg-earthcopilot --query "[0].name" -o tsv
.\scripts\enable-webapp-auth.ps1 -ResourceGroupName rg-earthcopilot -WebAppName $webAppName
```

> **Note:** The local script does not persist across CI/CD redeployments unless you save the Client ID as `AUTH_CLIENT_ID`.

---

## Step 13 (Optional): Integrate with Microsoft Copilot Studio

**Why?** Your analysts already live in **Microsoft Teams** and **M365 Copilot**. Instead of switching to a separate web app, Copilot Studio lets them search satellite imagery and analyze terrain directly from their chat window — no context switching. It's the fastest path to adoption for organizations already on Microsoft 365.

Copilot Studio acts as a **distribution channel** — all AI intelligence stays in your deployed backend. No code changes needed.

| What You Get | How It Works |
|---|---|
| Chat with Earth Copilot in Teams | Copilot Studio agent calls your Container App API |
| Search satellite imagery via natural language | `searchSatelliteImagery` action |
| Analyze terrain at coordinates | `analyzeTerrainAtLocation` action |
| Multi-turn terrain conversations | `chatWithTerrainAgent` with session memory |

**Getting started:** Create a Copilot Studio agent with a custom connector pointing to your deployed backend API. See [Microsoft Copilot Studio documentation](https://learn.microsoft.com/microsoft-copilot-studio/) for setup instructions.

> **Requirements:** Copilot Studio license (included in M365 E3/E5 or standalone) + deployed Earth Copilot backend.

---

## Step 14 (Optional): Connect via MCP Server

**Why?** If your developers use **GitHub Copilot**, **Claude**, or other AI coding assistants, the MCP (Model Context Protocol) server lets them query satellite data and analyze terrain **directly from their IDE** — no browser, no API docs, no curl commands. The AI assistant discovers Earth Copilot's capabilities automatically and calls them in context.

| What You Get | How It Works |
|---|---|
| Query satellite imagery from VS Code Copilot Chat | MCP tools with dynamic capability discovery |
| Multi-turn conversations with context memory | MCP preserves session state across turns |
| Works with any MCP-compatible client | GitHub Copilot, Claude Desktop, custom agents |
| Domain-specific expert prompts | Built-in geospatial analyst personas |

**Follow the full guide:** [earth-copilot/mcp-server/README.md](earth-copilot/mcp-server/README.md)

> **Requirements:** Deployed Earth Copilot backend + an MCP-compatible client (GitHub Copilot in VS Code, Claude Desktop, etc.).

